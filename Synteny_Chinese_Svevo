```
#!/bin/bash
#SBATCH --account=co_minium
#SBATCH --partition=savio4_htc
#SBATCH --exclusive
#SBATCH --nodes=1
#SBATH --qos=minium_htc4_normal
#SBATCH --time=72:00:00
minimap2 -f100 -x asm20 -t 8 /global/scratch/users/jiaqitang0422/Tomato/10.Kronos_QC/split_kronos/Kronos.v1.1_7B.fa /global/scratch/users/jiaqitang0422/Kronos/Chinese_spring/Chinese_spring_7B.fa -o minimap_K.CS_7B.out.paf
```
**MInimap2 reference(target fa) comes first, and then is the query fa
```
(base) [jiaqitang0422@n0180 Kronos]$ minimap2 --help
Usage: minimap2 [options] <target.fa>|<target.idx> [query.fa] [...]
```
```
#!/bin/bash
#SBATCH --account=co_minium
#SBATCH --partition=savio4_htc
#SBATCH --exclusive
#SBATCH --nodes=1
#SBATH --qos=minium_htc4_normal
#SBATCH --time=72:00:00
minimap2 -f100 -x asm20 -t 8 /global/scratch/users/jiaqitang0422/Tomato/10.Kronos_QC/split_kronos/Kronos.v1.1_3B.fa /global/scratch/users/jiaqitang0422/Kronos/Svevo.v1/Svevo.v1_3B.fna -o minimap_K.SV_3B.out.paf
```
```
#!/bin/bash
#SBATCH --account=co_minium
#SBATCH --partition=savio4_htc
#SBATCH --exclusive
#SBATCH --nodes=1
#SBATCH --cpus-per-task=56
#SBATH --qos=minium_htc4_normal
#SBATCH --time=72:00:00
minimap2 -f100 -x asm20 -t 56 Sohab_cornell_assembly.fna SH.haplotype-1.final.scaffolds.fa > minimap_hap1_cornell.out.paf
```
- Synteny generation:

python synteny_plot.py minimap_K.CS_7B.out.paf 7B 7B
python synteny_plot.py minimap_K.SV_1B.out.paf LT934112.1 1B
scp jiaqitang0422@dtn.brc.berkeley.edu:/global/scratch/users/jiaqitang0422/Kronos/LT934111.1_vs_1A.global.svg /Users/r_upercut/Downloads/test/minimap2

"I have a task for you. You need to write a Python script that I can use on the cluster to create a new fasta file based on the given fasta file. I now have a fast file called "Kronos.collapsed.chromosomes.masked.v1.1.fa.NLR_loci.fa", and this file looks like this ">1A_2600127-2634529
TTGGCATGTCTAATTGAAGGAGCTGACTGCTAAAAAAATTGAATGAGCCGTGTGTTTTTCTCAGGCGAATTGGGTTAGTCATGGGTTCCCAGGGGCATTGCTCCATGTTGCTCGATTAGTCACTGTCTGTTGCATGCTCAACCAGCTGTTTAGTGTTTGCTTTCCATTTTTTTATAGAGGAATTAGGGGTATGAACTGATTGAATAGGCCAATGTGCATGCACCAA...
>1A_7144666-7177894
tgcttgcaaagtttcatcatggaattacattcatggaatttgtcagaaaaataaaataaaattagcactccaaactgtttttgagaataacttttgtgaagcattgtatttgtttcctttgccacgtcgcccatgaatttcattctgtgatgaaactttgcaagaaatcaaaacatttgccaTATATAAAAGCATCTTCAACAGTGTCCATTTCTCCTAAAACTACC...
>1A_7229636-7290159
ctgacgttgagtaggcagataggccgaaattgttcaattctcacggcatctattttcttaggcaacaacgttatcgttccaaaattaagttggaacagctgcaagtgtcccgagaacaaatcatggaacatcggcatcaggtcccctttgataatatgccaacacttcttgtaaaactcagccgggaaaccatccggccccggagcctta...
>1A_8465878-8499976
aacaagagacagtaaaaaaggtttacgcagggtcttaatctaaaaagaatcctttaggacgggtccctactgcacgtctgcgcctgtgtctccgttgtgtcgtatcctggacgggcgtcgcacgacattcatctgtaaaagagaggaactgagttgaaaacgggtcgtgccgaaaaaagtttaaaataaacaaagtataaaatatataa...
>1A_8513644-8547934
attcgtgaatctaataaaatatcaatgaaattttggaaaatactcaaaaaaaattccgtgagtttcattttttgccctattttaaaaaatcatcgattcaaaaagtgttcatgaattctaaaactactcatgtattcggtaaatgttcatcaatttttttttgtgaattttagaaaatgcccaatttttttaaaatgattgtcgattcagaaagctgtt...
". The name of every scaffold follows the pattern {1A} which is the name of the chromosome the sequence is on, and the second part {7144666-7177894} which is the position of the segment sequence on that chromosome (recorded as {starting point}-{end point}). There are 14 chromosomes starting with 1A, 1B, 2A, 2B, 3A, 3B, 4A, 4B, and all the way to 7A and 7B. For each chromosome,
For each chromosome, create a dictionary storing the name of the chromosome as the key, and every segment (this means that the value is a list of tuples of the starting point and the ending point of each segment. Using these 14 intermediate dictionaries, I want you to merge overlapping segments into 1 segment with the new starting position and the ending position. 
If there are multiple overlapping segments, please merge all of them into 1 segment. After you get the position for new segments, you need to write a fasta file to record the segment name in {chromosome name}_{new starting position}-{new end position} and their sequence as well. You might have to parse the original fasta file to do this. Name the final output fasta file "New_Kronos_loci.fa""

```
/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/makeblastdb -in Chinese_spring_1B.fa -out 1B -dbtype 'nucl'
/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/makeblastdb -in Chinese_spring_2B.fa -out 2B -dbtype 'nucl'
/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/makeblastdb -in Chinese_spring_1A.fa -out 1A -dbtype 'nucl'
/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/makeblastdb -in Svevo.v1_2A.fna -out 2A -dbtype 'nucl'
/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/makeblastdb -in Svevo.v1_1B.fna -out 1B -dbtype 'nucl'

#!/bin/bash
#SBATCH --account=co_minium
#SBATCH --partition=savio4_htc
#SBATCH --exclusive
#SBATCH --nodes=1
#SBATCH --qos=minium_htc4_normal
#SBATCH --time=72:00:00
/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/blastn -query /global/scratch/users/jiaqitang0422/Kronos/2B.fa -db ./2B -outfmt "6 std qlen slen" -out K.CS.2B.blast.out -evalue 1e-6 

#!/bin/bash
#SBATCH --account=co_minium
#SBATCH --partition=savio4_htc
#SBATCH --mem=512000
#SBATCH --exclusive
#SBATCH --nodes=1
#SBATCH --cpus-per-task=56
#SBATCH --qos=minium_htc4_normal
#SBATCH --time=72:00:00
/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/blastn -query /global/scratch/users/jiaqitang0422/Kronos/2A.fa -db ./2A -outfmt "6 std qlen slen" -out K.SV.2A.blast.out -evalue 1e-6 -threads 56
```
```
#!/bin/bash
#SBATCH --account=co_minium
#SBATCH --partition=savio4_htc
#SBATCH --exclusive
#SBATCH --nodes=1
#SBATCH --qos=minium_htc4_normal
#SBATCH --time=72:00:00
python synteny_blast.py /global/scratch/users/jiaqitang0422/Kronos/Chinese_spring/K.CS.1A.blast.out 1A_6144666-19273033 1A --start 1 --end 13128367 --hstart 6144666 --hend 19273033 --alignment_length 2800 --resize_param 1000000

#!/bin/bash
#SBATCH --account=co_minium
#SBATCH --partition=savio4_htc
#SBATCH --mem=512000
#SBATCH --exclusive
#SBATCH --nodes=1
#SBATCH --cpus-per-task=56
#SBATCH --qos=minium_htc4_normal
#SBATCH --time=72:00:00
python blast_vertical_synteny.py 2nd.K.CS.1A.blast.out 1A_6144666-19273033 1A --hstart 8144666 --hend 21273033

python test_blast_vertical_synteny.py K.CS.1A.blast.out 1A_6144666-19273033 1A 
python synteny_blast.py my_blast_output.txt "1A_6144666-19273033" "2A_50000-150000"



python synteny_blast.py /global/scratch/users/jiaqitang0422/Kronos/Chinese_spring/K.SV.1A.blast.out 1A_8144666-19273033 1A --start 1 --end 13128367 --hstart 6144666 --hend 19273033 --alignment_length 2800 --resize_param 1000000

/global/scratch/users/jiaqitang0422/Software/ncbi-blast-2.15.0+/bin/blastn -query 04B_06B_11B.fa -db ./NLR_synteny/db_filtered_chilense -outfmt "6 std qlen slen" -out hap1_VS_chilense.blast.out -evalue 1e-4 -num_threads 56

scp jiaqitang0422@dtn.brc.berkeley.edu:/global/scratch/users/jiaqitang0422/Kronos/Chinese_spring/1B_1-16279279_vs_1B_0-36279279.synteny.png /Users/r_upercut/Downloads/test/blast
1A_6144666-19273033_vs_1A.local.1-13128367.png
```

- SCript for vertical line function added to the synteny_blast.fa file
```
# -*- coding: utf-8 -*-
"""
Visualizing Synteny Plots for BLAST Output (Tabular Format 6) with Loci Annotations
"""

import argparse
import matplotlib.pyplot as plt
import re
from Bio import SeqIO

def resize(num, param):
    """Scale a number by a resize parameter."""
    return int(num) / param

def parse_loci(loci_fasta):
    """
    Parses loci from the fasta file and stores them by chromosome.
    
    Args:
        loci_fasta (str): Path to the loci fasta file.

    Returns:
        dict: A dictionary mapping chromosomes to a list of (start, end) tuples.
    """
    loci = {}

    for record in SeqIO.parse(loci_fasta, "fasta"):
        match = re.match(r"(\w+)_(\d+)-(\d+)", record.id)
        if match:
            chrom, start, end = match.groups()
            start, end = int(start), int(end)
            if chrom not in loci:
                loci[chrom] = []
            loci[chrom].append((start, end))

    return loci

# Initialize the parser
parser = argparse.ArgumentParser(description='Generate a synteny plot from BLAST output with loci annotations.')
parser.add_argument('blast_file', help='Path to the BLAST output file.')
parser.add_argument('query', help='Query sequence name (e.g., "1A_6144666-19273033").')
parser.add_argument('hit', help='Hit sequence name for comparison.')
parser.add_argument('--loci_fasta', default="/global/scratch/users/jiaqitang0422/Kronos/Kronos.collapsed.chromosomes.masked.v1.1.fa.NLR_loci.fa",
                    help='Path to the loci fasta file.')
parser.add_argument('--alignment_length', type=int, default=7000, help='Minimum alignment length to be processed.')
parser.add_argument('--resize_param', type=int, default=1000000, help='Parameter to resize the plot (in Mb).')

# Parse arguments
args = parser.parse_args()

# Extract query chromosome, start, and end
query_match = re.match(r"(\w+)_(\d+)-(\d+)", args.query)
if not query_match:
    raise ValueError("Query name must follow the format {chromosome}_{start}-{end}")

query_chrom, query_start, query_end = query_match.groups()
query_start, query_end = int(query_start), int(query_end)

# Normalize start and end for plotting (start at 1)
adjusted_start = 1
adjusted_end = query_end - query_start + 1

# Lists to store coordinates
start_x, start_y, end_x, end_y = [], [], [], []

# Read BLAST file and extract relevant alignments
with open(args.blast_file, 'r') as file:
    for line in file:
        items = line.split()

        # Extract BLASTn fields
        qseqid = items[0]    # Query sequence ID
        sseqid = items[1]    # Subject sequence ID
        length = int(items[3])    # Alignment length
        qstart = int(items[6])    # Query start
        qend = int(items[7])      # Query end
        sstart = int(items[8])    # Subject start
        send = int(items[9])      # Subject end

        # Check if alignment is within the query range and meets length threshold
        if qseqid == args.query and sseqid == args.hit and length >= args.alignment_length:
            # Normalize query coordinates for plotting
            qstart_adj = qstart - query_start + 1
            qend_adj = qend - query_start + 1

            start_x.append(resize(qstart_adj, args.resize_param))
            end_x.append(resize(qend_adj, args.resize_param))
            start_y.append(resize(sstart, args.resize_param))
            end_y.append(resize(send, args.resize_param))

# Load loci
loci = parse_loci(args.loci_fasta)

# Plot with matplotlib
fig, ax = plt.subplots()

# Set x and y limits based on adjusted query and hit coordinates
ax.set_xlim(resize(adjusted_start, args.resize_param), resize(adjusted_end, args.resize_param))
ax.set_ylim(resize(adjusted_start, args.resize_param), resize(adjusted_end, args.resize_param))

# Plot synteny lines
for sx, sy, ex, ey in zip(start_x, start_y, end_x, end_y):
    ax.plot([sx, ex], [sy, ey], color='k')

# Plot loci as vertical green lines
if query_chrom in loci:
    for locus_start, locus_end in loci[query_chrom]:
        if query_start <= locus_start <= query_end:
            locus_adj_start = locus_start - query_start + 1
            ax.axvline(x=resize(locus_adj_start, args.resize_param), color='g', linestyle='--', linewidth=1)

        if query_start <= locus_end <= query_end:
            locus_adj_end = locus_end - query_start + 1
            ax.axvline(x=resize(locus_adj_end, args.resize_param), color='g', linestyle='--', linewidth=1)

# Customize plot
ax.set_xlabel(f'{query_chrom} ({query_start}-{query_end} bp)')
ax.set_ylabel(f'{args.hit} (Mb)')

# Save the plot
output_dir = '/global/scratch/users/jiaqitang0422/Kronos/Chinese_spring'
plt.savefig(f'{output_dir}/{args.query}_vs_{args.hit}.synteny.png', format='png')

print("Plot successfully saved!")

```
```
# -*- coding: utf-8 -*-
"""
Visualizing Synteny Plots for BLAST Output (Tabular Format 6) with Loci Annotations.
"""

import argparse
import matplotlib.pyplot as plt
import re
from Bio import SeqIO

def resize(num, param):
    """Scale a number by a resize parameter."""
    return int(num) / param

def parse_loci(loci_fasta):
    """
    Parses loci from the fasta file and stores them by chromosome.

    Args:
        loci_fasta (str): Path to the loci fasta file.

    Returns:
        dict: A dictionary mapping chromosomes to a list of middle positions of loci.
    """
    loci = {}

    for record in SeqIO.parse(loci_fasta, "fasta"):
        match = re.match(r"(\w+)_(\d+)-(\d+)", record.id)
        if match:
            chrom, start, end = match.groups()
            start, end = int(start), int(end)
            middle = (start + end) // 2  # Compute the middle of the locus
            if chrom not in loci:
                loci[chrom] = []
            loci[chrom].append(middle)  # Store middle point instead of start/end

    return loci

# Initialize the parser
parser = argparse.ArgumentParser(description='Generate a synteny plot from BLAST output with loci annotations.')
parser.add_argument('blast_file', help='Path to the BLAST output file.')
parser.add_argument('query', help='Query sequence name (e.g., "1A_6144666-19273033").')
parser.add_argument('hit', help='Hit sequence name for comparison.')
parser.add_argument('--loci_fasta', default="../Kronos.collapsed.chromosomes.masked.v1.1.fa.NLR_loci.fa",
                    help='Path to the loci fasta file.')
parser.add_argument('--alignment_length', type=int, default=5000, help='Minimum alignment length to be processed.')
parser.add_argument('--resize_param', type=int, default=1000000, help='Parameter to resize the plot (in Mb).')
parser.add_argument('--hstart', type=int, help='Starting coordinate for the hit (Y-axis).')
parser.add_argument('--hend', type=int, help='Ending coordinate for the hit (Y-axis).')

# Parse arguments
args = parser.parse_args()

# Extract query chromosome, start, and end
query_match = re.match(r"(\w+)_(\d+)-(\d+)", args.query)
if not query_match:
    raise ValueError("Query name must follow the format {chromosome}_{start}-{end}")

query_chrom, query_start, query_end = query_match.groups()
query_start, query_end = int(query_start), int(query_end)

# Set default hit start and end if not provided
if args.hstart is None:
    args.hstart = query_start
if args.hend is None:
    args.hend = query_end

# Normalize query start and end for plotting
adjusted_start = 1
adjusted_end = query_end - query_start

# Lists to store coordinates
start_x, start_y, end_x, end_y = [], [], [], []

# Read BLAST file and extract relevant alignments
with open(args.blast_file, 'r') as file:
    for line in file:
        items = line.split()

        # Extract BLASTn fields
        qseqid = items[0]    # Query sequence ID
        sseqid = items[1]    # Subject sequence ID
        length = int(items[3])    # Alignment length
        qstart = int(items[6])    # Query start
        qend = int(items[7])      # Query end
        sstart = int(items[8])    # Subject start
        send = int(items[9])      # Subject end

        # Check if alignment is within the query range and meets length threshold
        if qseqid == args.query and sseqid == args.hit and length >= args.alignment_length:

            start_x.append(resize(qstart, args.resize_param))
            end_x.append(resize(qend, args.resize_param))
            start_y.append(resize(sstart, args.resize_param))
            end_y.append(resize(send, args.resize_param))

# Load loci
loci = parse_loci(args.loci_fasta)

# Plot with matplotlib
fig, ax = plt.subplots()

# Set x and y limits based on adjusted query and hit coordinates
ax.set_xlim(resize(adjusted_start, args.resize_param), resize(adjusted_end, args.resize_param))
ax.set_ylim(resize(args.hstart, args.resize_param), resize(args.hend, args.resize_param))

# Plot synteny lines (alignment matches)
for sx, sy, ex, ey in zip(start_x, start_y, end_x, end_y):
    ax.plot([sx, ex], [sy, ey], color='k')

# Plot loci as solid green vertical lines at middle positions
if query_chrom in loci:
    for locus_middle in loci[query_chrom]:
        if query_start <= locus_middle <= query_end:
            locus_adj_middle = locus_middle - query_start
            ax.axvline(x=resize(locus_adj_middle, args.resize_param), color='g', linestyle='-', linewidth=1)

# Customize plot labels with **original query coordinates**
ax.set_xlabel(f'{query_chrom} ({query_start}-{query_end} bp)')
ax.set_ylabel(f'{args.hit} (Mb)')

# Save the plot
output_dir = '/global/scratch/users/jiaqitang0422/Kronos/Chinese_spring'
plt.savefig(f'{output_dir}/{args.query}_vs_{args.hit}.synteny.png', format='png')

print("Plot successfully saved!")
```

- Segmented run for the blast file
1. python prepare_blast.py New_Krnons_loci.fa Svevo.v1_1A.fna = Query FASTA: 001_K_1A_6144666_19273033.fa
Hit FASTA: 001_SV_1A_0_39273033.fa
BLAST DB: 001_SV_1A_0_39273033
SLURM script: run_blast_SV_6144666_19273033.sh

2. python prepare_blast.py New_Krnons_loci.fa Svevo.v1_1B.fna
Query FASTA: 001_K_1B_1_16279279.fa
Hit FASTA: 001_SV_1B_0_36279279.fa
BLAST DB: 001_SV_1B_0_36279279
SLURM script: run_blast_SV_1_16279279.sh

3. python prepare_blast.py New_Krnons_loci.fa Svevo.v1_2A.fna
Query FASTA: 001_K_2A_10797061_18441796.fa
Hit FASTA: 001_SV_2A_0_38441796.fa
BLAST DB: 001_SV_2A_0_38441796
SLURM script: run_blast_SV_10797061_18441796.sh

4. python prepare_blast.py New_Krnons_loci.fa Svevo.v1_2B.fna
Query FASTA: 001_K_2B_812819653_821568195.fa
Hit FASTA: 001_SV_2B_792819653_841568195.fa
BLAST DB: 001_SV_2B_792819653_841568195
SLURM script: run_blast_SV_812819653_821568195.sh

5. Svevo.v1_3A.fna
Query FASTA: 001_K_3A_709479001_714785400.fa
Hit FASTA: 001_SV_3A_689479001_734785400.fa
BLAST DB: 001_SV_3A_689479001_734785400
SLURM script: run_blast_SV_709479001_714785400.sh

6. Svevo.v1_3B.fna
Query FASTA: 001_K_3B_61893014_70588348.fa
Hit FASTA: 001_SV_3B_41893014_90588348.fa
BLAST DB: 001_SV_3B_41893014_90588348
SLURM script: run_blast_SV_61893014_70588348.sh

7. Svevo.v1_4A.fna
Query FASTA: 001_K_4A_742788751_767865717.fa
Hit FASTA: 001_SV_4A_722788751_787865717.fa
BLAST DB: 001_SV_4A_722788751_787865717
SLURM script: run_blast_SV_742788751_767865717.sh

8. Svevo.v1_4B.fna
Query FASTA: 001_K_4B_2287435_9190132.fa
Hit FASTA: 001_SV_4B_0_29190132.fa
BLAST DB: 001_SV_4B_0_29190132
SLURM script: run_blast_SV_2287435_9190132.sh

9 Svevo.v1_5A.fna
Query FASTA: 001_K_5A_18226803_23832148.fa
Hit FASTA: 001_SV_5A_0_43832148.fa
BLAST DB: 001_SV_5A_0_43832148
SLURM script: run_blast_SV_18226803_23832148.sh

10. Svevo.v1_5B.fna
Query FASTA: 001_K_5B_25087707_37743160.fa
Hit FASTA: 001_SV_5B_5087707_57743160.fa
BLAST DB: 001_SV_5B_5087707_57743160
SLURM script: run_blast_SV_25087707_37743160.sh

11. Svevo.v1_6A.fna 
Query FASTA: 001_K_6A_610739952_621701839.fa
Hit FASTA: 001_SV_6A_590739952_641701839.fa
BLAST DB: 001_SV_6A_590739952_641701839
SLURM script: run_blast_SV_610739952_621701839.sh

12. Svevo.v1_6B.fna 
Query FASTA: 001_K_6B_52322263_60605353.fa
Hit FASTA: 001_SV_6B_32322263_80605353.fa
BLAST DB: 001_SV_6B_32322263_80605353
SLURM script: run_blast_SV_52322263_60605353.sh

13. Svevo.v1_7A.fna 
Query FASTA: 001_K_7A_1_11887879.fa
Hit FASTA: 001_SV_7A_0_31887879.fa
BLAST DB: 001_SV_7A_0_31887879
SLURM script: run_blast_SV_1_11887879.sh

14. Svevo.v1_7B.fna 
Query FASTA: 001_K_7B_749873542_765942456.fa
Hit FASTA: 001_SV_7B_729873542_785942456.fa
BLAST DB: 001_SV_7B_729873542_785942456
SLURM script: run_blast_SV_749873542_765942456.sh

- Chinese Spring segmented blast run with largest overlapped loci
1. Chinese_spring_2B.fa
Query FASTA: 001_K_2B_812819653_821568195.fa
Hit FASTA: 001_CS_2B_792819653_841568195.fa
BLAST DB: 001_CS_2B_792819653_841568195
SLURM script: run_blast_CS_812819653_821568195.sh
2. Chinese_spring_3A.fa
Query FASTA: 001_K_3A_709479001_714785400.fa
Hit FASTA: 001_CS_3A_689479001_734785400.fa
BLAST DB: 001_CS_3A_689479001_734785400
SLURM script: run_blast_CS_709479001_714785400.sh
3. Chinese_spring_3B.fa
Query FASTA: 001_K_3B_61893014_70588348.fa
Hit FASTA: 001_CS_3B_41893014_90588348.fa
BLAST DB: 001_CS_3B_41893014_90588348
SLURM script: run_blast_CS_61893014_70588348.sh
4. Chinese_spring_4A.fa
Query FASTA: 001_K_4A_742788751_767865717.fa
Hit FASTA: 001_CS_4A_722788751_787865717.fa
BLAST DB: 001_CS_4A_722788751_787865717
SLURM script: run_blast_CS_742788751_767865717.sh
5. Chinese_spring_4B.fa
Query FASTA: 001_K_4B_2287435_9190132.fa
Hit FASTA: 001_CS_4B_0_29190132.fa
BLAST DB: 001_CS_4B_0_29190132
SLURM script: run_blast_CS_2287435_9190132.sh
6. Chinese_spring_5A.fa
Query FASTA: 001_K_5A_18226803_23832148.fa
Hit FASTA: 001_CS_5A_0_43832148.fa
BLAST DB: 001_CS_5A_0_43832148
SLURM script: run_blast_CS_18226803_23832148.sh
7. Chinese_spring_5B.fa
Query FASTA: 001_K_5B_25087707_37743160.fa
Hit FASTA: 001_CS_5B_5087707_57743160.fa
BLAST DB: 001_CS_5B_5087707_57743160
SLURM script: run_blast_CS_25087707_37743160.sh
8. Chinese_spring_6A.fa
Query FASTA: 001_K_6A_610739952_621701839.fa
Hit FASTA: 001_CS_6A_590739952_641701839.fa
BLAST DB: 001_CS_6A_590739952_641701839
SLURM script: run_blast_CS_610739952_621701839.sh
9. Chinese_spring_6B.fa
Query FASTA: 001_K_6B_52322263_60605353.fa
Hit FASTA: 001_CS_6B_32322263_80605353.fa
BLAST DB: 001_CS_6B_32322263_80605353
SLURM script: run_blast_CS_52322263_60605353.sh
10. Chinese_spring_7A.fa
Query FASTA: 001_K_7A_1_11887879.fa
Hit FASTA: 001_CS_7A_0_31887879.fa
BLAST DB: 001_CS_7A_0_31887879
SLURM script: run_blast_CS_1_11887879.sh
11. Chinese_spring_7B.fa
Query FASTA: 001_K_7B_749873542_765942456.fa
Hit FASTA: 001_CS_7B_729873542_785942456.fa
BLAST DB: 001_CS_7B_729873542_785942456
SLURM script: run_blast_CS_749873542_765942456.sh

